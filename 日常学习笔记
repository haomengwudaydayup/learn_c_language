在一个函数内部修改全局变量的值会影响其它函数，全局变量的值在函数内部被修改后并不会自动恢复，它会一直保留该值，直到下次被修改。

整形提升
1、
char a = -1;
printf("a = %d\n",a);
printf("Ua = %d\n",a);

由于-1是32位存储的，但是char只能接收8位，（运算取决于补码）
//10000000000000000000000000000001  --> -1的原码
//11111111111111111111111111111111  --> -1的补码 （操作码）
由于char是有符号字符型，因此整形提升要补1  即接下来：
//11111111111111111111111111111111  %u打印形式 
它的补码为%d打印形式
//10000000000000000000000000000001 --> %d
因此打印为2^32-1 和 -1

2、
unsigned char a = -1;
printf("a = %d\n",a);
printf("Ua = %d\n",a);
//10000000000000000000000000000001  --> -1的原码
//11111111111111111111111111111111  --> -1的补码 （操作码）
由于char是无符号字符型，因此整形提升要补0 即接下来：
//00000000000000000000000011111111  --> %U %d
unsigned类型的整形提升打印%d%u是一样的，只有有符号整形提升打印不一样

-------------------------------------------------------------------------------------
1、malloc()
由于malloc()的返回值时(void*)，因此需要强转一下。
(int *)malloc(sizeof(int) * size);
//分配size字节的空间
2、calloc()
3、realloc()
(int *)realloc(ptr , n * sizeof(int));
原型：void* realloc(void *ptr, size_t size);
功能：对 ptr 指向的内存重新分配 size 大小的空间，size 可比原来的大或者小，还可以不变（如果你无聊的话）-- 呵呵。
4、free(ptr)统一释放

-------------------------------------------------------------------------
1、因为每次程序申请或者释放堆空间都要进行系统调用。我们知道系统调用的性能开销是比较大的，当程2、序对堆的操作比较频繁时，这样做的结果会严重影响程序的性能。
堆内存从低地址向高地址连续分配

3、malloc() 和 free() 所做的工作主要是对已有内存块的分拆和合并，并没有频繁地向操作系统申请内存，这大大提高了内存分配的效率
4、采用双向链表来控制内存的管理

堆使用的不利之处：
一旦链表中的 pre 或 next 指针被破坏，整个堆就无法工作，而这些数据恰恰很容易被越界读写所接触到。
小的空闲区域往往不容易再次分配，形成很多内存碎片。
经常分配和释放内存会造成链表过长，增加遍历的时间。

5、要想规避野指针，就要养成良好的编程习惯：
1) 指针变量如果暂时不需要赋值，一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。
2) 当指针指向的内存被释放掉时，要将指针的值设置为 NULL，因为 free() 只是释放掉了内存，并为改变指针的值

6、使用 malloc()、calloc()、realloc() 动态分配的内存，如果没有指针指向它，就无法进行任何操作，这段内存会一直被程序占用，直到程序运行结束由操作系统回收。

7、常量区和全局数据区的内存在程序启动时就已经由操作系统分配好，占用的空间固定，程序运行期间不再改变，程序运行结束后才由操作系统释放；它可以存放全局变量、静态变量、一般常量和字符串常量。


关于寄存器变量有以下事项需要注意：
1) 为寄存器变量分配寄存器是动态完成的，因此，只有局部变量和形式参数才能定义为寄存器变量。

2) 局部静态变量不能定义为寄存器变量，因为一个变量只能声明为一种存储类别。

3) 寄存器的长度一般和机器的字长一致，只有较短的类型如 int、char、short 等才适合定义为寄存器变量，诸如 double 等较大的类型，不推荐将其定义为寄存器类型。

4) CPU的寄存器数目有限，即使定义了寄存器变量，编译器可能并不真正为其分配寄存器，而是将其当做普通的auto变量来对待，为其分配栈内存。当然，有些优秀的编译器，能自动识别使用频繁的变量，如循环控制变量等，在有可用的寄存器时，即使没有使用 register 关键字，也自动为其分配寄存器，无须由程序员来指定。
---------------------------------------------------------------------------------------------------------------------------

